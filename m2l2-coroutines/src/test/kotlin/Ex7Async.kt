import kotlinx.coroutines.CoroutineStart
import kotlinx.coroutines.async
import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import kotlin.test.Test
import kotlin.time.measureTime

/**
 * Класс для демонстрации работы с корутинами, возвращающими результат.
 * Билдер `async` запускает корутину и возвращает специальный объект `Deferred`,
 * который является "обещанием" будущего результата.
 * `await()` — это функция, которая приостанавливает выполнение до тех пор,
 * пока результат не будет готов, и затем возвращает его.
 */
class Ex7Async {

  /**
   * Базовый пример использования `async`.
   * Две задачи запускаются параллельно, и мы ждем их результатов.
   */
  @Test
  fun async1(): Unit = runBlocking { // runBlocking создает скоуп для теста
    // 1. Запускаем первую асинхронную задачу.
    //    `async` немедленно запускает корутину и возвращает объект Deferred<Int>.
    //    Задача будет выполняться параллельно с остальным кодом.
    val res1 = async {
      delay(1000) // Имитация долгой операции (1 секунда)
      println("async1 completed")
      42 // Возвращаемый результат типа Int
    }

    // 2. Запускаем вторую асинхронную задачу. Она тоже начнет выполняться немедленно.
    val res2 = async {
      delay(500) // Имитация операции (0.5 секунды)
      println("async2 completed")
      42 // Возвращаемый результат типа Int
    }

    // 3. `await()` приостанавливает текущую корутину (runBlocking) и ждет,
    //    пока соответствующая `async`-задача не завершится.
    //    Поскольку мы вызываем `await()` для обеих задач, runBlocking будет ждать,
    //    пока обе они не завершатся.
    //    Общее время ожидания будет примерно равно времени самой долгой задачи (~1000мс),
    //    а не сумме их времен, потому что они выполнялись КОНКУРЕНТНО.
    println("completed: ${res1.await()}, ${res2.await()}")
  }

  /**
   * Демонстрация ленивого запуска с `CoroutineStart.LAZY`.
   * Корутина не запускается сразу, а только при вызове `await()` или `start()`.
   */
  @Test
  fun asyncLazy(): Unit = runBlocking {
    // 1. Создаем "ленивые" корутины. Они НЕ запускаются сразу.
    //    Они просто создаются и находятся в состоянии "создано".
    val res1 = async(start = CoroutineStart.LAZY) {
      println("async1 started")
      delay(1000)
      println("async1 completed")
      42
    }
    val res2 = async(start = CoroutineStart.LAZY) {
      println("async2 started")
      delay(500)
      println("async2 completed")
      66
    }

    // Если бы мы раскомментировали эти строки, корутины бы запустились параллельно,
    // и общее время выполнения было бы ~1000мс, как в первом тесте.
    // res1.start()
    // res2.start()

    delay(1000) // Этот delay выполняется в runBlocking. Корутины все еще не запущены.
    println("we are here")

    // 2. measureTime — удобная утилита для измерения времени выполнения блока кода.
    val dur = measureTime {
      // 3. Здесь происходит запуск и ожидание.
      //    Вызов `res1.await()` ЗАПУСКАЕТ первую корутину и ЖДЕТ её завершения (1000мс).
      //    Только после её завершения, вызов `res2.await()` ЗАПУСКАЕТ вторую корутину и ЖДЕТ её (500мс).
      //    Поскольку запуск происходит последовательно, общее время будет СУММОЙ задержек.
      println("completed: ${res1.await()}, ${res2.await()}")
    }
    println("Duration: $dur") // Выведет продолжительность примерно в 1500мс.
  }
}