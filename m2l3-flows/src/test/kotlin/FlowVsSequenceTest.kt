import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlin.test.Test

/**
 * Демонстрация квазипараллельной работы flow и корутин по сравнению с последовательностями.
 * Обратите внимание на скорость выполнения тестов и на порядок вывода в консоль.
 *
 * Dispatchers.IO.limitedParallelism(1) — это ключевой элемент. Он создает диспетчер,
 * который использует ровно один поток из пула потоков IO. Это делается для того,
 * чтобы создать контролируемую среду и наглядно показать, как блокирующие операции
 * (Thread.sleep) "убивают" параллелизм, в то время как приостанавливающие (delay) — нет.
 */
class FlowVsSequenceTest {

  /**
   * Этот тест демонстрирует поведение Sequence в асинхронной среде корутин.
   * Sequence предназначен для синхронной, "жадной" (хоть и ленивой) обработки данных.
   */
  @OptIn(ExperimentalCoroutinesApi::class)
  @Test
  fun sequenceTest(): Unit = runBlocking(Dispatchers.IO.limitedParallelism(1)) {
    // Мы создаем последовательность. Код внутри блока sequence {...} будет выполняться,
    // когда мы вызовем терминальный оператор (forEach в нашем случае).
    val simpleSequence = sequence {
      for (i in 1..5) {
        // ВАЖНО: Внутри sequence нельзя использовать приостанавливающие функции (suspend functions),
        // такие как delay(). Это приведет к ошибке компиляции.
        // delay(1000) // <- так нельзя

        // Вместо этого мы вынуждены использовать Thread.sleep().
        // Thread.sleep() — это БЛОКИРУЮЩАЯ операция. Она "замораживает" ВЕСЬ поток,
        // в котором она выполняется, на указанное время.
        // В нашем случае это единственный поток, который выделил limitedParallelism(1).
        Thread.sleep(1000)
        yield(i) // "Излучаем" следующее значение
      }
    }

    // Запускаем вторую корутину, которая должна работать "параллельно".
    launch {
      for (k in 1..5) {
        println("Я не заблокирован $k")
        delay(1000) // delay() - ПРИОСТАНАВЛИВАЮЩАЯ операция. Она не блокирует поток.
      }
    }

    // Запускаем обработку последовательности. Этот код будет выполняться в том же единственном потоке.
    // Так как он содержит блокирующий Thread.sleep(), он захватит поток на 5 секунд.
    // Корутина, запущенная через launch, не сможет выполниться, пока forEach не закончится.
    simpleSequence.forEach { println(it) }

    // Ожидаемый порядок вывода:
    // 1
    // 2
    // 3
    // 4
    // 5
    // Я не заблокирован 1
    // Я не заблокирован 2
    // ...
    // Общее время выполнения ~10 секунд (5 сек на sequence, потом 5 сек на launch).
  }

  /**
   * Этот тест демонстрирует поведение Flow, который был создан для асинхронной работы.
   */
  @Test
  fun flowTest(): Unit = runBlocking(Dispatchers.IO.limitedParallelism(1)) {
    // Создаем поток (Flow). Код внутри блока flow {...} также ленив.
    val simpleFlow = flow {
      for (i in 1..5) {
        // ВАЖНО: Внутри flow мы можем и должны использовать приостанавливающие функции.
        // delay() - это ПРИОСТАНАВЛИВАЮЩАЯ операция.
        // Она не блокирует поток, а лишь приостанавливает выполнение *текущей корутины*.
        // Поток в это время свободен и может выполнять другую работу (например, корутину из launch).
        delay(1000)
        emit(i) // "Излучаем" следующее значение
      }
    }

    // Запускаем вторую корутину.
    launch {
      for (k in 1..5) {
        println("Я не заблокирован $k")
        delay(1000)
      }
    }

    // Запускаем сбор потока.
    // Когда выполнение дойдет до delay(1000) внутри flow, корутина потока "заснет",
    // освободив единственный поток. Диспетчер корутин немедленно переключится на выполнение
    // корутины из launch. Она напечатает сообщение и тоже "заснет" на delay(1000).
    // Этот процесс будет повторяться, обеспечивая чередующуюся (квазипараллельную) работу.
    simpleFlow.collect { println(it) }

    println("Flow end")

    // Ожидаемый порядок вывода (может незначительно меняться, но будет чередоваться):
    // Я не заблокирован 1
    // 1
    // Я не заблокирован 2
    // 2
    // ...
    // Flow end
    // Общее время выполнения ~5 секунд, так как обе задачи выполняются параллельно (на одном потоке).
  }
}