import junit.framework.TestCase.assertEquals
import kotlin.test.Test

class SequenceTest {

  /**
   * В коллекции операторы преобразования (такие как map, filter) являются "жадными" (eager).
   * Это означает, что каждый оператор в цепочке полностью обрабатывает всю коллекцию,
   * создает новую коллекцию с результатами и передает ее следующему оператору.
   *
   * Давайте разберем, что происходит здесь шаг за шагом.
   */
  @Test
  fun collectionIsNotLazy() {
    listOf(1, 2, 3, 4)
      // 1. Оператор .map для коллекций (List, Set) "жадный". Он немедленно проходит
      //    по *всем* элементам исходной коллекции, применяет к ним преобразование
      //    и создает *новую* коллекцию в памяти.
      //    В нашем случае он создаст новую коллекцию: [(1, 1), (2, 4), (3, 9), (4, 16)]
      .map {
        println("map for $it -> ${it * it}") // Этот println выполнится для КАЖДОГО элемента (1, 2, 3, 4)
        it to it * it
      }
      // 2. Только после того, как `map` полностью завершит свою работу и вернет новую коллекцию,
      //    начнет выполняться `.first`.
      //    Он начнет перебирать уже готовую коллекцию [(1, 1), (2, 4), (3, 9), (4, 16)].
      .first {
        println("first for ${it.first}") // Этот println выполнится для элементов, пока не найдется нужный.
        it.first == 3
      }
    // Ожидаемый вывод в консоли:
    // map for 1 -> 1
    // map for 2 -> 4
    // map for 3 -> 9
    // map for 4 -> 16
    // first for 1
    // first for 2
    // first for 3
    //
    // Ключевой момент: `map` выполнил лишнюю работу для элемента 4 (и даже для 1 и 2),
    // так как `first` ему понадобился только третий элемент.
  }

  /**
   * В последовательности (Sequence) операторы преобразования "ленивые" (lazy).
   * Они не выполняют код немедленно, а строят "конвейер" операций.
   * Реальное выполнение начинается только при вызове "терминальной" операции,
   * которой нужен конечный результат (например, first, toList, forEach).
   *
   * Элементы проходят по конвейеру по одному, а не вся коллекция целиком.
   */
  @Test
  fun sequenceIsLazy() {
    listOf(1, 2, 3, 4).asSequence() // .asSequence() превращает "жадную" коллекцию в "ленивую" последовательность
      .map {
        // Этот код не выполнится сразу. Он будет вызван для каждого элемента,
        // только когда `.first` его запросит.
        println("map for $it -> ${it * it}")
        it to it * it
      }
      .first {
        // `.first` - это терминальная операция, которая запускает всю цепочку.
        println("first for ${it.first}")
        it.first == 3
      }

    // Пошаговое выполнение:
    // 1. `.first` запрашивает первый элемент из последовательности.
    // 2. Последовательность передает элемент `1` в `.map`.
    // 3. `.map` выполняет свой код для `1`, выводит 'map for 1...' и возвращает результат `(1, 1)`.
    // 4. Этот результат `(1, 1)` передается в `.first`.
    // 5. `.first` проверяет условие `it.first == 3`. Оно ложно. Переходим к следующему элементу.
    // 6. Повторяем для элемента `2`. Условие снова ложно.
    // 7. Переходим к элементу `3`. `.map` выводит 'map for 3...', `.first` проверяет условие - оно истинно.
    // 8. Цепочка останавливается. Элемент `4` никогда не будет обработан.

    // Ожидаемый вывод в консоли:
    // map for 1 -> 1
    // first for 1
    // map for 2 -> 4
    // first for 2
    // map for 3 -> 9
    // first for 3
    //
    // Обратите внимание: `map` для элемента `4` **никогда не будет вызван**.
    // Это и есть суть ленивых вычислений — мы выполняем только минимально необходимую работу.
  }


  /**
   * Этот пример показывает главный недостаток Sequence для асинхронных операций.
   * Последовательности выполняют все операции последовательно в одном потоке.
   * Они не предоставляют параллелизма.
   */
  @Test
  fun blockingCall() {
    // Мы создаем последовательность и применяем к ней `.map`.
    // Внутри `map` мы вызываем `Thread.sleep(3000)`.
    // Это **блокирующий** вызов. Он "замораживает" текущий поток выполнения (thread) на 3 секунды.
    val sequence = sequenceOf(1, 2, 3)
      .map {
        println("Make blocking call to API for element $it") // Добавим вывод для наглядности
        Thread.sleep(3000) // Имитация долгой блокирующей операции (например, синхронного запроса в сеть)
        it + 1
      }
      .toList() // `.toList()` - терминальная операция, которая запускает выполнение.

    println("Sequence: $sequence")

    // Что произойдет:
    // 1. Запустится обработка элемента `1`. Поток засыпает на 3 секунды.
    // 2. Запустится обработка элемента `2`. Поток снова засыпает на 3 секунды.
    // 3. Запустится обработка элемента `3`. И еще 3 секунды сна.
    // Вся операция займет около 9 секунд, так как все выполняется последовательно в одном потоке.
    // Этот недостаток покрывается в корутинах и Flow, которые позволяют выполнять такие операции
    // асинхронно, не блокируя основной поток.
  }

  /**
   * Демонстрация "холодного" (cold) поведения последовательностей.
   * "Холодный" означает, что последовательность не выполняет код и не хранит данные,
   * пока ее об этом не попросят (с помощью терминальной операции).
   * Каждый раз, когда вы запрашиваете данные, вся обработка начинается с нуля.
   */
  @Test
  fun coldFeature() {
    // Здесь мы лишь *описываем* рецепт создания последовательности с помощью блок-функции `sequence`.
    // Код внутри `sequence { ... }` **не выполняется** в этот момент.
    // `yield(x)` "выдает" значение `x` и приостанавливает выполнение до запроса следующего.
    val seq = sequence {
      var x = 0
      for (i in (1..15)) {
        x += i
        println("Yielding $x") // Добавим для отслеживания
        yield(x)
      }
    }

    // Эти строки тоже не выполняют код. Они просто создают новые "цепочки" операций,
    // которые будут применены к `seq`, когда это понадобится.
    val s1 = seq.map { it }
    val s2 = seq.map { it * 2 }

    println("--- Запуск S1 ---")
    // Это первая терминальная операция. Она запускает выполнение `seq` с самого начала.
    // Последовательность сгенерирует все значения, `map` их применит, и `toList` соберет в список.
    println("S1: ${s1.toList()}") // <-- Здесь seq вызывается ВПЕРВЫЕ

    println("\n--- Запуск S2 ---")
    // Это вторая терминальная операция. Она **полностью заново** запускает выполнение `seq`!
    // Весь код внутри `sequence { ... }` будет выполнен еще раз с самого начала.
    println("S2: ${s2.toList()}") // <-- Здесь seq вызывается ВТОРОЙ раз с нуля
  }

  /**
   * Этот тест демонстрирует два основных способа создания последовательностей-генераторов.
   */
  @Test
  fun generators() {
    // 1. Блок-функция `sequence { ... }`:
    //    Это самый гибкий способ. Внутри блока можно писать любой код,
    //    используя `yield(value)` для выдачи следующего элемента.
    //    Здесь мы просто выдаем числа от 1 до 10.
    val seq = sequence {
      for (i in 1..10) {
        yield(i)
      }
    }
    // `.sum()` - терминальная операция, которая запускает `seq` и суммирует все элементы.
    assertEquals(55, seq.sum())

    // 2. Функция `generateSequence`:
    //    Удобный способ для создания простых, часто бесконечных, последовательностей.
    //    Она принимает начальное значение (seed) и функцию, которая вычисляет следующее
    //    значение на основе предыдущего.
    //    В нашем случае `generateSequence(1) { it + 1 }` создает бесконечную
    //    последовательность натуральных чисел: 1, 2, 3, 4, ...
    val seq1 = generateSequence(1) { it + 1 }

    // Чтобы с бесконечной последовательностью можно было работать, мы используем
    // ленивый оператор `.take(10)`, который берет только первые 10 элементов.
    // После этого `.sum()` их суммирует.
    assertEquals(55, seq1.take(10).sum())
  }

}