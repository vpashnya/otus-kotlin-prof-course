import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.catch
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.retry
import kotlinx.coroutines.runBlocking
import kotlin.test.Test

class ExceptionsTest {

  /**
   * Это базовый поток, который мы будем использовать для демонстрации.
   * Он намеренно генерирует исключение после второго элемента.
   * Обратите внимание, что после исключения есть еще два `emit`.
   * Это ключевой момент: как только в потоке происходит исключение, он завершается,
   * и последующие значения никогда не будут излучены.
   */
  private val flow = flow {
    delay(500)
    emit("1")
    delay(500)
    emit("2")

    // Здесь происходит сбой. Будет сгенерировано исключение ArithmeticException.
    val a = 1 / 0

    // Этот код никогда не будет выполнен.
    delay(500)
    emit("3")
    delay(500)
    emit("4")
  }

  /**
   * Способ 1: Использование стандартного блока try-catch.
   * Это самый простой и понятный способ, который работает как в обычном коде.
   * Мы оборачиваем всю операцию сбора данных (`collect`) в try-catch.
   */
  @Test
  fun exception() = runBlocking {
    try {
      // Запускаем сбор потока. Если внутри потока произойдет исключение,
      // оно будет "проброшено" наружу и поймано здесь.
      flow.collect { println(it) }
    } catch (e: Exception) {
      // Перехватываем исключение и обрабатываем его.
      println("Поймано исключение: $e")
    }
    // Ожидаемый вывод:
    // 1
    // 2
    // Поймано исключение: java.lang.ArithmeticException: / by zero
    // Значения "3" и "4" не будут выведены, так как поток был аварийно завершен.
  }

  /**
   * Способ 2: Использование оператора .catch().
   * Это более "идиоматичный" для Flow способ. Оператор `catch` встраивается
   * прямо в цепочку обработки потока.
   * Он перехватывает исключения, которые произошли в потоке *выше* по цепочке (upstream).
   */
  @Test
  fun catchOperator() = runBlocking {
    flow
      // .catch() перехватывает исключение из `flow`.
      // После того как исключение поймано, поток завершается.
      // Код внутри catch может, например, излучить значение-заглушку или просто залогировать ошибку.
      .catch { e -> println("Оператор .catch поймал: $e") }
      .collect { println(it) }

    // Ожидаемый вывод:
    // 1
    // 2
    // Оператор .catch поймал: java.lang.ArithmeticException: / by zero
    // Обратите внимание: `collect` больше не получает значений после того, как `catch` сработал.
  }

  /**
   * Способ 3: Использование оператора .retry() для повторных попыток.
   * Этот оператор полезен, когда ошибки могут быть временными (например, ошибка сети).
   * `retry(2)` означает: "Если в потоке произойдет исключение, попробуй запустить его заново.
   * Сделай это не более 2 раз". Если после 2 попыток ошибка все еще есть, передай ее дальше по цепочке.
   */
  @Test
  fun retryOperator() = runBlocking {
    flow
      // .retry(2) будет перезапускать поток при ошибке.
      .retry(2) { e ->
        // Этот блок кода выполняется при каждой ошибке перед повторной попыткой.
        // Здесь можно, например, вывести лог или подождать некоторое время.
        println("Произошла ошибка ${e.message}, повторная попытка...")
        true // Возвращаем `true`, чтобы подтвердить, что мы хотим повторить попытку.
      }
      // Если все попытки `retry` исчерпаны, исключение передается дальше,
      // где его может поймать оператор .catch().
      .catch { e -> println("Все попытки неудачны. Финальное исключение: $e") }
      .collect { println(it) }

    // Пошаговый разбор выполнения:
    // 1. **Первая попытка:** Поток запускается, выводит "1", "2", и падает с ошибкой.
    //    `retry` ловит ее и запускает поток заново.
    // 2. **Вторая попытка:** Поток снова запускается, выводит "1", "2", и снова падает.
    //    `retry` ловит ее и запускает поток в третий (и последний) раз.
    // 3. **Третья попытка:** Поток в третий раз запускается, выводит "1", "2", и падает.
    //    `retry` больше не может делать попыток, поэтому он передает исключение дальше.
    // 4. `.catch` ловит это финальное исключение и выводит сообщение.

    // Ожидаемый вывод:
    // 1
    // 2
    // Произошла ошибка / by zero, повторная попытка...
    // 1
    // 2
    // Произошла ошибка / by zero, повторная попытка...
    // 1
    // 2
    // Все попытки неудачны. Финальное исключение: java.lang.ArithmeticException: / by zero
  }
}