### Формулировка задания

**Цель:** Рефакторить код, чтобы сделать его асинхронным и высокопроизводительным, используя корутины для параллельного
выполнения сетевых запросов.

**Задача:**

1. **Модифицировать `DictionaryApi.findWord`:**
    * Преобразуйте её в `suspend`-функцию.
    * Оберните блокирующий сетевой вызов `HttpClient.get(url).execute()` в `withContext(Dispatchers.IO) { ... }`. Это
      стандартный паттерн для выполнения блокирующих I/O-операций в мире корутин. Он переключит выполнение на
      специальный пул потоков для I/O, выполнит там сетевой запрос, а затем вернет результат, не блокируя основной пул
      потоков.

2. **Модифицировать `findWords`:**
    * Преобразуйте её в `suspend`-функцию.
    * Замените последовательный `words.map { ... }` на параллельное выполнение. Для этого идеально подходит комбинация
      `async` и `awaitAll()`:
        * Используйте `async`, чтобы запустить поиск для каждого слова в отдельной корутине. Это создаст список
          `Deferred`-объектов (обещаний).
        * Используйте `awaitAll()` для этого списка, чтобы дождаться завершения всех запросов.

3. **Обновить тест `hardHw`:**
    * Оберните логику теста в билдер `runBlocking`, чтобы создать корутину, из которой можно будет вызывать новые
      `suspend`-функции.

**Ожидаемый результат:**

После выполнения задания все сетевые запросы будут отправляться параллельно. Общее время выполнения будет определяться
не суммой времен всех запросов, а временем самого долгого из них, что приведет к колоссальному ускорению.