import kotlinx.coroutines.delay
import kotlinx.coroutines.runBlocking
import kotlin.test.Test

/**
 * Класс для демонстрации того, как компилятор Kotlin преобразует suspend-функции.
 *
 * Основная идея: компилятор превращает каждую suspend-функцию в "конечный автомат" (state machine).
 * Этот автомат отслеживает, на каком этапе выполнения находится корутина, и может
 * приостанавливать и возобновлять её работу, не блокируя поток.
 *
 * Как декомпилировать файл в IntelliJ IDEA (как указано в комментариях к коду):
 * 1. Соберите проект (Build -> Build Project).
 * 2. Найдите скомпилированный .class файл. Обычно он находится в:
 *    `build/classes/kotlin/main/your/package/name/Ex4Decompile.class`
 * 3. Кликните правой кнопкой мыши по .class файлу -> Decompile.
 *    Или через меню: Tools -> Kotlin -> Show Kotlin Bytecode -> Decompile.
 *
 * Вы увидите сгенерированный Java-код, где будет класс `ContinuationImpl`,
 * целочисленная переменная `label` (состояние автомата) и большой `switch-case`,
 * который и есть наш конечный автомат.
 */
class Ex4Decompile {

  /**
   * Главная suspend-функция для анализа. У неё несколько точек приостановки (suspension points).
   * Каждая точка приостановки (вызов другой suspend-функции, например, delay) — это
   * переход в новое состояние для конечного автомата.
   */
  private suspend fun someMethod(): String {
    // --- СОСТОЯНИЕ 0 (Начало) ---
    // Локальные переменные 'a' и 'b' не могут храниться в стеке, потому что
    // функция будет приостановлена. Компилятор сохранит их в специальном объекте
    // Continuation, который "путешествует" вместе с корутиной.
    var a = 1
    var b = "x"
    println("1 $a $b")

    // --- ПЕРВАЯ ТОЧКА ПРИОСТАНОВКИ ---
    // Компилятор превратит этот вызов в нечто вроде:
    // 1. Сохранить текущее состояние (например, label = 1).
    // 2. Сохранить значения a=1, b="x" в объекте Continuation.
    // 3. Вызвать delay, который приостановит выполнение.
    // 4. Вернуть специальный флаг COROUTINE_SUSPENDED.
    delay(100)

    // --- СОСТОЯНИЕ 1 (Возобновление после delay(100)) ---
    // Когда корутина возобновится, код начнет выполняться отсюда.
    // Компилятор восстановит значения 'a' и 'b' из Continuation.
    a += otherMethod(5)
    b += "y"
    println("2 $a $b")

    // --- ВТОРАЯ ТОЧКА ПРИОСТАНОВКИ ---
    // Аналогично первой: сохранить состояние (label = 2), сохранить переменные, приостановиться.
    delay(200)

    // --- СОСТОЯНИЕ 2 (Возобновление после delay(200)) ---
    a += 3
    b = withCatch(b)
    println("3 $a $b")

    // --- ЗАВЕРШЕНИЕ ---
    // Функция завершается, возвращая результат. Конечный автомат переходит в завершенное состояние.
    return "Some data $a $b"
  }

  /**
   * Вспомогательная suspend-функция. Её логика также будет преобразована в конечный автомат.
   */
  private suspend fun otherMethod(a: Int): Int {
    if (a == 0) return -1 // Это обычный, синхронный возврат. Точки приостановки нет.

    var b = a
    for (i in 1..10) {
      // Точка приостановки внутри цикла. Состояние будет сохраняться на каждой итерации.
      delay(50)
      b += 2
    }
    return b
  }

  /**
   * Пример обработки исключений в suspend-функции.
   * Компилятор корректно встроит логику try-catch в сгенерированный конечный автомат.
   */
  private suspend fun withCatch(a: String): String {
    try {
      // Если delay выбросит CancellationException (например), она будет перехвачена здесь.
      delay(100)
    } catch(e: Exception) {
      // При возобновлении после исключения выполнение пойдет по этой ветке.
      return "ex"
    }
    return "$a ok"
  }

  /**
   * Тест для запуска нашего кода.
   */
  @Test
  fun coro(): Unit = runBlocking {
    // runBlocking создает корутину и блокирует текущий поток до её завершения.
    // Он является "корневым" для запускаемой someMethod().
    // Вызов someMethod() на самом деле запускает её конечный автомат.
    someMethod()
  }
}